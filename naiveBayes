#!/usr/bin/python

import math

# The main method
def main():
    global numInputs
    global numVectors
    f1 = open('netflix-train.txt')
    seq1 = f1.read()
    numInputs = readNumInputs(seq1)
    numVectors = readNumVectors(seq1)
    global data
    data = getFeatures(seq1)
    probY = getProbY()

    tables = []
    for i in range(0, numInputs):
        counts = calculateCounts(i)
        mle = calculateMLE(counts)
        tables.append(mle)

    tablesMap = []
    for i in range(0, numInputs):
        countsLaPlace = calculateCountsLaPlace(i)
        map = calculateMAP(countsLaPlace)
        tablesMap.append(map)

    #testing part
    f2 = open('netflix-test.txt')
    seq2 = f2.read()
    global numVectorsTest
    numVectorsTest = readNumVectors(seq2)
    testing = getFeaturesTest(seq2)
    predictions = makePredictions(testing, tables, probY)
    #predictions = makePredictionsLog(testing, tables, probY)
    predictionsLaPlace = makePredictions(testing, tablesMap, probY) #LaPlace Estimator
    print "MLE: "
    accuracy = getAccuracy(predictions, testing)
    print "Accuracy MLE: ",accuracy, "%\n"
    print "LaPlace: "
    #accuracyMap = getAccuracy(predictionsLaPlace, testing)
    #print "Accuracy LaPlace: ",accuracyMap, "%\n"
    #print predictions
    calculate1C()
    #calculate1B()


def readNumInputs(seq):
    numInputs= 10*(int(seq[0])) + int(seq[1]) #2
    return numInputs

def readNumVectors(seq):
    numVectors = (1000*(int(seq[3]))) + (100*(int(seq[4]))) + (10*(int(seq[5]))) + (int(seq[6]))
    return numVectors

def getAccuracy(predictions, testing):
    correct = 0.0
    class0Correct = 0.0
    class1Correct = 0.0
    class0 = 0.0
    class1 = 0.0
    for i in range(0, len(predictions)):
        if testing[i][numInputs]==0:
            class0+=1
        if testing[i][numInputs]==1:
            class1+=1
        if (predictions[i]==testing[i][numInputs]):
            if (testing[i][numInputs])==0:
                class0Correct+=1
            if testing[i][numInputs]==1:
                class1Correct+=1
            correct = correct+1
        elif predictions[i]!=testing[i][numInputs]:
            print i, testing[i]
    print "Class 0: tested ", class0, ", correctly classified: ", class0Correct
    print "Class 1: tested ", class1, ", correctly classified: ", class1Correct
    return 100*correct/float(numVectorsTest)


def makePredictions(testing, tables, probY):
    predictions = []
    for k in range(0, numVectorsTest):
        # y=0
        prob0 = 1.0
        for i in range(0, numInputs):
            x = testing[k][i]
            prob0 = prob0 * tables[i][x] / probY[0]
        prob0 = prob0 * probY[0]

        # y=1
        prob1 = 1.0
        for i in range(0, numInputs):
            x = testing[k][i]
            prob1 = prob1 * tables[i][x + 2] / probY[1]
        prob1 = prob1 * probY[1]

        if (prob0 > prob1):
            predictions.append(0)
        else:
            predictions.append(1)
    return predictions

def makePredictionsLog(testing, tables, probY):
    predictions = []
    for k in range(0, numVectorsTest):
        # y=0
        prob0 = 0.0
        for i in range(0, numInputs):
            x = testing[k][i]
            if (tables[i][x]!=0)&(probY[0]!=0):
                prob0 = prob0 + math.log(tables[i][x]) - math.log(probY[0])

        prob0 = prob0 + math.log(probY[0])

        # y=1
        prob1 = 0.0
        for i in range(0, numInputs):
            x = testing[k][i]
            if (tables[i][x+2]!=0)&(probY[1]!=0):
                prob1 = prob1 + math.log(tables[i][x + 2])-math.log(probY[1])
        prob1 = prob1 + math.log(probY[1])

        if (prob0 > prob1):
            predictions.append(0)
        else:
            predictions.append(1)
    return predictions


def calculateMLE(counts):
    mle = []
    for i in range(0, 4):
        mle.append(float(counts[i])/float(numVectors))
    return mle

def calculateMAP(countsLaPlace):
    map = []
    for i in range(0, 4):
        map.append(float(countsLaPlace[i])/(float(numVectors)+float(4)))
    return map


def calculateCounts(j):
    counts = initializeCounts()
    for i in range(0, numVectors):
        x = data[i][j]
        y = data[i][numInputs]
        counts[x+(2*y)] = counts[x+(2*y)] + 1
    return counts

def calculateCountsLaPlace(j):
    counts = initializeCounts()
    for i in range(0, numVectors):
        x = data[i][j]
        y = data[i][numInputs]
        counts[x+(2*y)] = counts[x+(2*y)] + 1
    for i in range(0, 4):
        counts[i] +=1
    return counts


def initializeCounts():
    counts = []
    for i in range(0, 4):
        counts.append(0)
    return counts


def getProbY():
    probY = []
    num0 = 0.0
    num1 = 0.0
    for i in range(0, numVectors):
        if (data[i][numInputs] == 0):
            num0 = num0 + 1
        if (data[i][numInputs] == 1):
            num1 = num1 + 1
    probY.append(num0 / float(numVectors))
    probY.append(num1 / float(numVectors))
    return probY


def getFeatures(seq1):
    vectors = []
    k = 7
    for j in range(0, numVectors):
        features = []
        for i in range(0, numInputs+numInputs+3):
            #print (k+i)
            if (seq1[k + i] != "\n")&(seq1[k+i]!=',')&(seq1[k+i]!=" ")&(seq1[k+i]!=":"):
                features.append(int(seq1[k + i]))
        k = k + numInputs + numInputs + 3
        vectors.append(features)
    return vectors

def getFeaturesTest(seq1):
    vectors = []
    k = 7
    for j in range(0, numVectorsTest):
        features = []
        for i in range(0, numInputs+numInputs+3):
            #print (k+i)
            if (seq1[k + i] != "\n")&(seq1[k+i]!=',')&(seq1[k+i]!=" ")&(seq1[k+i]!=":"):
                features.append(int(seq1[k + i]))
        k = k + numInputs + numInputs + 3
        vectors.append(features)
    return vectors


def calculate1Cold():
    ratios = []
    for i in range(0, numInputs):
        numX1 = 0.0
        numX0 = 0.0
        numY0 = 0.0
        numY1 = 0.0
        for j in range(0, numVectors):
            #print data[j][i]
            if data[j][i]==1:
                #print "ONE"
                numX1+=1
                if data[j][numInputs]==1:
                    numY1+=1
            #prob1 = numY1/numX1
            elif data[j][i]==0:
                #print "ZdfsfsdfsdfsdfsdfERO"
                numX0+=1
                #print data[j][numInputs]
                if data[j][numInputs]==1:
                    numY0+=1
                    #print "KDJFKSKFJSJFKSJDF"
            #print numX0
            #prob0 = numY0/numX0
        #print numY1
        #print numX1
        #print numY0
        #print "i: ", i
        #print numX0
        prob1 = numY1/numX1
        prob0 = numY0/numX0
        if (prob1==0)|(prob0==0):
            ratios.append(0)
        else:
            ratios.append(prob1/prob0)
    for i in range(0, numInputs):
        print i+1, ": ", ratios[i]


def calculate1C():
    ratios = []
    probs1 = []
    probs0 = []

    #calculate P(y=1|xi=1)
    for i in range(0, numInputs):
        numX = 0.0
        numXandY = 0.0
        for j in range(0, numVectors):
            if data[j][i]==1:
                numX+=1
                if data[j][numInputs]==1:
                    numXandY+=1
        prob1 = numXandY/numX
        probs1.append(prob1)


    #calculate P(y=1|xi=0)
    for i in range(0, numInputs):
        numX= 0.0
        numXandY=0.0
        for j in range(0, numVectors):
            if data[j][i]==0:
                numX+=1
                if data[j][numInputs]==1:
                    numXandY+=1
        prob0 = numXandY/numX
        probs0.append(prob0)

    for i in range(0, numInputs):
        ratios.append(probs1[i]/probs0[i])
    for i in range(0, numInputs):
        print i+1, ": ", ratios[i]

def calculate1B():
    probs = []
    for i in range(0, numInputs):
        numY = 0.0
        count = 0.0
        for j in range(0, numVectors):
            if data[j][numInputs] == 0:
                numY += 1
                if data[j][i] == 1:
                    count += 1

        probs.append(count / numY)
    print probs

# This if statement passes if this
# was the file that was executed
if __name__ == '__main__':
    main()
